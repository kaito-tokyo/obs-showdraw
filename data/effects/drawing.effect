uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d image1;

// Common parameters
uniform float texelWidth;
uniform float texelHeight;
uniform int kernelSize;

// Motion adaptive filtering parameters
uniform texture2d motionMap;
uniform float strength;
uniform float motionThreshold;

// Sobel magnitude finalization parameter
uniform bool useLog;
uniform float scalingFactor;

// Canny edge detection parameters
uniform float highThreshold;
uniform float lowThreshold;

#define PI 3.14159265359f
#define SQRT_20 4.472136f
#define TAN_22_5 0.41421356f
#define TAN_67_5 2.41421356f

sampler_state def_sampler
{
	Filter = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertInOut {
	float4 pos : POSITION;
	float2 uv : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;
	return vert_out;
}

#include "drawing-pixelshaders.effect"

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDraw(vert_in);
	}
}

technique DrawGrayscale
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDrawGrayscale(vert_in);
	}
}

technique ConvertGrayscale
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSConvertGrayscale(vert_in);
	}
}

technique HorizontalMedian3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian3(vert_in);
	}
}

technique HorizontalMedian5
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian5(vert_in);
	}
}

technique HorizontalMedian7
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian7(vert_in);
	}
}

technique HorizontalMedian9
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian9(vert_in);
	}
}

technique VerticalMedian3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian3(vert_in);
	}
}

technique VerticalMedian5
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian5(vert_in);
	}
}

technique VerticalMedian7
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian7(vert_in);
	}
}

technique VerticalMedian9
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian9(vert_in);
	}
}

technique CalculateHorizontalMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateHorizontalMotionMap(vert_in);
	}
}

technique CalculateVerticalMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateVerticalMotionMap(vert_in);
	}
}

technique MotionAdaptiveFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSMotionAdaptiveFiltering(vert_in);
	}
}

technique ApplySobel
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSApplySobel(vert_in);
	}
}

technique FinalizeSobelMagnitude
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSFinalizeSobelMagnitude(vert_in);
	}
}

technique SuppressNonMaximum
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSSuppressNonMaximum(vert_in);
	}
}

technique HysteresisClassify
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHysteresisClassify(vert_in);
	}
}

technique HysteresisPropagate
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHysteresisPropagate(vert_in);
	}
}

technique HysteresisFinalize
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHysteresisFinalize(vert_in);
	}
}

technique HorizontalErosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalErosion(vert_in);
	}
}

technique VerticalErosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalErosion(vert_in);
	}
}

technique HorizontalDilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalDilation(vert_in);
	}
}

technique VerticalDilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalDilation(vert_in);
	}
}
