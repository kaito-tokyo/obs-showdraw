uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d image1;

// Common parameters
uniform float texelWidth;
uniform float texelHeight;
uniform int kernelSize;

// Motion adaptive filtering parameters
uniform texture2d motionMap;
uniform float strength;
uniform float motionThreshold;

// Sobel magnitude finalization parameter
uniform float scalingFactor;
uniform bool applyLog;

// Canny edge detection parameters
uniform float highThreshold;
uniform float lowThreshold;

#define PI 3.14159265359f
#define SQRT_20 4.472136f
#define TAN_22_5 0.41421356f
#define TAN_67_5 2.41421356f

sampler_state def_sampler {
	Filter   = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertInOut {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = vert_in.uv;
	return vert_out;
}

//
// Role:      Simply draws the source texture.
// Prerequisite: Original Source (e.g., video input from OBS).
// Input:     The original color image from the 'image' texture.
// Uniforms:  None.
// Output:    The same color image as the input.
//
float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(def_sampler, vert_in.uv);
}

//
// Role:      Converts a color image to a grayscale luminance map. This is the starting point for most subsequent operations.
// Prerequisite: Original Source (e.g., video input from OBS).
// Input:     The original color image from the 'image' texture.
// Uniforms:  None.
// Output:    A grayscale image with the luminance value stored in the .rgb channels (r=g=b).
//
float4 PSExtractLuminance(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(def_sampler, vert_in.uv);
	float luma = saturate(dot(color.rgb, float3(0.299, 0.587, 0.114)));
	return float4(luma, luma, luma, 1.0);
}

#define MEDIAN_SWAP(a,b) { float temp=a; a=min(a,b); b=max(temp,b); }

float median3(float v0, float v1, float v2) {
    float a = min(v0, v1);
    float b = max(v0, v1);
    return max(a, min(b, v2));}

float median5(float v0, float v1, float v2, float v3, float v4) {
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v0, v3);
    MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v2, v3);
    MEDIAN_SWAP(v1, v2);
    return v2;
}

float median7(float v0, float v1, float v2, float v3, float v4, float v5, float v6) {
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v5, v6);
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v2, v3); MEDIAN_SWAP(v4, v5);
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v5, v6);
    MEDIAN_SWAP(v0, v3); MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v2, v5);
    MEDIAN_SWAP(v3, v6); MEDIAN_SWAP(v1, v3); MEDIAN_SWAP(v2, v4);
    MEDIAN_SWAP(v3, v5); MEDIAN_SWAP(v2, v3);
    return v3;
}

float median9(float v0,float v1,float v2,float v3,float v4,float v5,float v6,float v7,float v8) {
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v4, v5); MEDIAN_SWAP(v7, v8);
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v6, v7);
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v4, v5); MEDIAN_SWAP(v7, v8);
    MEDIAN_SWAP(v0, v3); MEDIAN_SWAP(v5, v8); MEDIAN_SWAP(v4, v7);
    MEDIAN_SWAP(v3, v6); MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v2, v5);
    MEDIAN_SWAP(v4, v7); MEDIAN_SWAP(v4, v2); MEDIAN_SWAP(v6, v4);
    MEDIAN_SWAP(v4, v2);
    return v4;
}

//
// Role:      Applies a separable median filter to reduce noise.
// Prerequisite: PSExtractLuminance (or any other shader that outputs a grayscale image).
// Input:     A single-channel image in 'image.r' (e.g., a luminance map).
// Uniforms:  kernelSize, texelWidth, texelHeight.
// Output:    A grayscale image with the median-filtered value in the .rgb channels.
//
float4 PSMedianFiltering(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float final_median;

	if (kernelSize == 1) {
		final_median = image.Sample(def_sampler, uv).r;
	} else if (kernelSize == 3) {
		int radius = 1;
		float p[9];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*3 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[3];
		for (int i = 0; i < 3; i++) {
			h_medians[i] = median3(p[i*3+0], p[i*3+1], p[i*3+2]);
		}
		final_median = median3(h_medians[0], h_medians[1], h_medians[2]);
	} else if (kernelSize == 5) {
		int radius = 2;
		float p[25];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*5 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[5];
		for (int i = 0; i < 5; i++) {
			h_medians[i] = median5(p[i*5+0], p[i*5+1], p[i*5+2], p[i*5+3], p[i*5+4]);
		}
		final_median = median5(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4]);
	} else if (kernelSize == 7) {
		int radius = 3;
		float p[49];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*7 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[7];
		for (int i = 0; i < 7; i++) {
			h_medians[i] = median7(p[i*7+0], p[i*7+1], p[i*7+2], p[i*7+3], p[i*7+4], p[i*7+5], p[i*7+6]);
		}
		final_median = median7(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4], h_medians[5], h_medians[6]);
	} else if (kernelSize == 9) {
		int radius = 4;
		float p[81];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*9 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[9];
		for (int i = 0; i < 9; i++) {
			h_medians[i] = median9(p[i*9+0], p[i*9+1], p[i*9+2], p[i*9+3], p[i*9+4], p[i*9+5], p[i*9+6], p[i*9+7], p[i*9+8]);
		}
		final_median = median9(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4], h_medians[5], h_medians[6], h_medians[7], h_medians[8]);
	} else {
		return image.Sample(def_sampler, vert_in.uv);
	}

	return float4(final_median, final_median, final_median, 1.0);
}

//
// Role:      Calculates a motion map by comparing two frames to detect areas of movement.
// Prerequisite: Two separate luminance maps (e.g., from two PSExtractLuminance passes on different frames).
// Input:     'image.r' (current frame luminance), 'image1.r' (previous frame luminance).
// Uniforms:  kernelSize, texelWidth, texelHeight.
// Output:    A motion map with the amount of motion (SAD: Sum of Absolute Differences) in the .rgb channels.
//
float4 PSCalculateMotionMap(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float sad = 0.0;
	int radius = kernelSize / 2;

	for (int y = -radius; y <= radius; y++) {
		for (int x = -radius; x <= radius; x++) {
			float luma = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			float luma1 = image1.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			sad += abs(luma - luma1);
		}
	}

	sad /= float(kernelSize * kernelSize);

	return float4(sad, sad, sad, 1.0);
}

//
// Role:      Performs motion adaptive filtering by blending between two frames based on pixel-wise difference.
// Prerequisite: Two grayscale images.
// Input:     'image.r' (e.g., noisy current frame), 'image1.r' (e.g., filtered previous frame).
// Uniforms:  motionThreshold, strength.
// Output:    A grayscale image with the adaptively filtered value in the .rgb channels.
//
float4 PSMotionAdaptiveFiltering(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	float luma1 = image1.Sample(def_sampler, vert_in.uv).r;
	float diff = abs(luma - luma1);
	float motionFactor = smoothstep(0.0, motionThreshold, diff);
	float blendFactor = strength * motionFactor;
	float finalLuma = lerp(luma1, luma, blendFactor);
	return float4(finalLuma, finalLuma, finalLuma, 1.0);
}

//
// Role:      [Canny Step 1] Applies the Sobel operator to calculate the gradient magnitude and direction.
// Prerequisite: PSExtractLuminance or PSMedianFiltering.
// Input:     A grayscale image in 'image.r'.
// Uniforms:  texelWidth, texelHeight.
// Output:    .r = Gradient Magnitude (normalized), .g = Gx (encoded to [0,1]), .b = Gy (encoded to [0,1]).
//
float4 PSApplySobel(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float luma[9];
	luma[0] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, -1.0f)).r;
	luma[1] = image.Sample(def_sampler, uv + texel_size * float2( 0.0f, -1.0f)).r;
	luma[2] = image.Sample(def_sampler, uv + texel_size * float2( 1.0f, -1.0f)).r;
	luma[3] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f,  0.0f)).r;
	luma[4] = image.Sample(def_sampler, uv).r;
	luma[5] = image.Sample(def_sampler, uv + texel_size * float2( 1.0f,  0.0f)).r;
	luma[6] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f,  1.0f)).r;
	luma[7] = image.Sample(def_sampler, uv + texel_size * float2( 0.0f,  1.0f)).r;
	luma[8] = image.Sample(def_sampler, uv + texel_size * float2( 1.0f,  1.0f)).r;

	float gx = -luma[0] - 2.0f * luma[3] - luma[6] + luma[2] + 2.0f * luma[5] + luma[8];
	float gy = -luma[0] - 2.0f * luma[1] - luma[2] + luma[6] + 2.0f * luma[7] + luma[8];
	float magnitude = sqrt(gx * gx + gy * gy);

	// Normalize by a typical maximum gradient magnitude
	magnitude = saturate(magnitude / SQRT_20);
	gx = saturate(gx / 8.0f + 0.5f);
	gy = saturate(gy / 8.0f + 0.5f);

	return float4(magnitude, gx, gy, 1.0f);
}

//
// Role:      Adjusts the gradient magnitude with a scaling factor or logarithmic transformation.
// Prerequisite: PSSuppressNonMaximum (or any other shader that outputs a grayscale magnitude).
// Input:     A gradient magnitude in 'image.r'.
// Uniforms:  applyLog, scalingFactor.
// Output:    A grayscale image with the adjusted magnitude in the .rgb channels.
//
float4 PSFinalizeSobelMagnitude(VertInOut vert_in) : TARGET
{
	float magnitude = image.Sample(def_sampler, vert_in.uv).r;
	if (applyLog) {
		magnitude = log(1.0f + magnitude) / log(2.0f);
	}
	magnitude = saturate(magnitude * scalingFactor);
	return float4(magnitude, magnitude, magnitude, 1.0f);
}

//
// Role:      [Canny Step 2] Performs non-maximum suppression to thin edges.
// Prerequisite: PSApplySobel.
// Input:     Encoded Sobel data from 'image' (.r=Magnitude, .g=Gx, .b=Gy).
// Uniforms:  texelWidth, texelHeight.
// Output:    A grayscale image with thinned edges in the .rgb channels. Non-maximal pixels are set to 0.
//
float4 PSSuppressNonMaximum(VertInOut vert_in) : TARGET
{
	float4 encoded = image.Sample(def_sampler, vert_in.uv);
	float encoded_magnitude = encoded.r;
	float gx = (encoded.g - 0.5f) * 8.0f;
	float gy = (encoded.b - 0.5f) * 8.0f;

	float2 offset = float2(0.0f, 0.0f);
	float gx_abs = abs(gx);
	float gy_abs = abs(gy);

	if (gy_abs < gx_abs * TAN_22_5) {
		offset = float2(texelWidth, 0.0f);
	} else if (gy_abs > gx_abs * TAN_67_5) {
		offset = float2(0.0f, texelHeight);
	} else {
		offset = float2(texelWidth, texelHeight);
		// If gradient is in the 2nd or 4th quadrant (e.g., top-right to bottom-left edge),
		// flip the y-component of the offset.
		if ((gx > 0.0f && gy < 0.0f) || (gx < 0.0f && gy > 0.0f)) {
			offset.y = -1.0f;
		}
	}

	float neighbor_encoded_magnitude1 = image.Sample(def_sampler, vert_in.uv + offset).r;
	float neighbor_encoded_magnitude2 = image.Sample(def_sampler, vert_in.uv - offset).r;

	if (encoded_magnitude < neighbor_encoded_magnitude1 || encoded_magnitude < neighbor_encoded_magnitude2)
	{
		encoded_magnitude = 0.0f;
	}

	return float4(encoded_magnitude, encoded_magnitude, encoded_magnitude, 1.0f);
}

//
// Role:      [Canny Step 3] Classifies pixels into strong (1.0), weak (0.5), or non-edges (0.0) using two thresholds.
// Prerequisite: PSSuppressNonMaximum (or PSFinalizeSobelMagnitude if it was used for adjustment).
// Input:     A thinned, grayscale edge map in 'image.r'.
// Uniforms:  highThreshold, lowThreshold.
// Output:    A classification map in the .rgb channels (1.0 for strong, 0.5 for weak, 0.0 for non-edge).
//
float4 PSHysteresisClassify(VertInOut vert_in) : TARGET
{
	float encoded_magnitude = image.Sample(def_sampler, vert_in.uv).r;

	if (encoded_magnitude >= highThreshold) {
		return float4(1.0, 1.0, 1.0, 1.0);
	} else if (encoded_magnitude >= lowThreshold) {
		return float4(0.5, 0.5, 0.5, 1.0);
	} else {
		return float4(0.0, 0.0, 0.0, 1.0);
	}
}

//
// Role:      [Canny Step 4] Connects edges by promoting weak edges (0.5) to strong ones (1.0) if they are adjacent to a strong edge.
// Prerequisite: PSHysteresisClassify.
// Input:     A classification map in 'image.r'.
// Uniforms:  texelWidth, texelHeight.
// Output:    An updated classification map in the .rgb channels.
//
float4 PSHysteresisPropagate(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float center_val = image.Sample(def_sampler, uv).r;

	if (center_val < 0.5f || center_val == 1.0f) {
		return float4(center_val, center_val, center_val, 1.0f);
	}

	for (int y = -1; y <= 1; y++) {
		for (int x = -1; x <= 1; x++) {
			if (x == 0 && y == 0) continue;
			float neighbor_val = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			if (neighbor_val == 1.0f) {
				return float4(1.0, 1.0, 1.0, 1.0);
			}
		}
	}
    
	return float4(center_val, center_val, center_val, 1.0f);
}

//
// Role:      [Canny Step 5] Finalizes the edge map by removing any remaining weak edges.
// Prerequisite: PSHysteresisPropagate.
// Input:     A propagated classification map in 'image.r'.
// Uniforms:  None.
// Output:    The final binary edge map in the .rgb channels (1.0 for edges, 0.0 for non-edges).
//
float4 PSHysteresisFinalize(VertInOut vert_in) : TARGET
{
	float val = image.Sample(def_sampler, vert_in.uv).r;
    
	if (val < 1.0f) {
		return float4(0.0f, 0.0f, 0.0f, 1.0f);
	}

	return float4(1.0f, 1.0f, 1.0f, 1.0f);
}

//
// Role:      Performs morphological erosion on a grayscale image.
// Prerequisite: PSHysteresisFinalize (or any other shader that outputs a single-channel image).
// Input:     A single-channel image in 'image.r' (e.g., a binary edge map).
// Uniforms:  kernelSize, texelWidth, texelHeight.
// Output:    An eroded grayscale image in the .rgb channels.
//
float4 PSErosion(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float min_val = 1.0;
	int radius = kernelSize / 2;

	if (radius > 0) {
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				min_val = min(min_val, image.Sample(def_sampler, uv + texel_size * float2(x, y)).r);
			}
		}
	} else {
		min_val = image.Sample(def_sampler, uv).r;
	}

	return float4(min_val, min_val, min_val, 1.0);
}

//
// Role:      Performs morphological dilation on a grayscale image.
// Prerequisite: PSHysteresisFinalize (or any other shader that outputs a single-channel image).
// Input:     A single-channel image in 'image.r' (e.g., a binary edge map).
// Uniforms:  kernelSize, texelWidth, texelHeight.
// Output:    A dilated grayscale image in the .rgb channels.
//
float4 PSDilation(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float max_val = 0.0;
	int radius = kernelSize / 2;

	if (radius > 0) {
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				max_val = max(max_val, image.Sample(def_sampler, uv + texel_size * float2(x, y)).r);
			}
		}
	} else {
		max_val = image.Sample(def_sampler, uv).r;
	}

	return float4(max_val, max_val, max_val, 1.0);
}

//
// Role:      Scales the brightness of an image by a uniform factor. A general-purpose utility.
// Prerequisite: Any preceding shader.
// Input:     A color or grayscale image from the 'image' texture.
// Uniforms:  scalingFactor.
// Output:    The scaled color or grayscale image.
//
float4 PSScaling(VertInOut vert_in) : TARGET
{
	return float4(image.Sample(def_sampler, vert_in.uv).rgb * scalingFactor, 1.0);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDraw(vert_in);
	}
}

technique ExtractLuminance
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSExtractLuminance(vert_in);
	}
}

technique MedianFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSMedianFiltering(vert_in);
	}
}

technique CalculateMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSCalculateMotionMap(vert_in);
	}
}

technique MotionAdaptiveFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSMotionAdaptiveFiltering(vert_in);
	}
}

technique ApplySobel
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSApplySobel(vert_in);
	}
}

technique FinalizeSobelMagnitude
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSFinalizeSobelMagnitude(vert_in);
	}
}

technique SuppressNonMaximum
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSSuppressNonMaximum(vert_in);
	}
}

technique HysteresisClassify
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSHysteresisClassify(vert_in);
	}
}

technique HysteresisPropagate
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSHysteresisPropagate(vert_in);
	}
}

technique HysteresisFinalize
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSHysteresisFinalize(vert_in);
	}
}

technique Erosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSErosion(vert_in);
	}
}

technique Dilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDilation(vert_in);
	}
}

technique Scaling
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSScaling(vert_in);
	}
}
