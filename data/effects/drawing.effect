uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d image1;

// Common parameters
uniform float texelWidth;
uniform float texelHeight;
uniform int kernelSize;

// Motion adaptive filtering parameters
uniform texture2d motionMap;
uniform float strength;
uniform float motionThreshold;

// Canny edge detection parameters
uniform float highThreshold;
uniform float lowThreshold;

// Scaling parameters
uniform float scalingFactor;

#define PI 3.14159265359f
#define SQRT_20 4.472136f
#define TAN_22_5 0.41421356f
#define TAN_67_5 2.41421356f

sampler_state def_sampler {
	Filter   = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertInOut {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = vert_in.uv;
	return vert_out;
}

float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(def_sampler, vert_in.uv);
}

float4 PSExtractLuminance(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(def_sampler, vert_in.uv);
	float luma = saturate(dot(color.rgb, float3(0.299, 0.587, 0.114)));
	return float4(luma, luma, luma, 1.0);
}

#define MEDIAN_SWAP(a,b) { float temp=a; a=min(a,b); b=max(temp,b); }

float median3(float v0, float v1, float v2) {
    float a = min(v0, v1);
    float b = max(v0, v1);
    return max(a, min(b, v2));}

float median5(float v0, float v1, float v2, float v3, float v4) {
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v0, v3);
    MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v2, v3);
    MEDIAN_SWAP(v1, v2);
    return v2;
}

float median7(float v0, float v1, float v2, float v3, float v4, float v5, float v6) {
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v5, v6);
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v2, v3); MEDIAN_SWAP(v4, v5);
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v5, v6);
    MEDIAN_SWAP(v0, v3); MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v2, v5);
    MEDIAN_SWAP(v3, v6); MEDIAN_SWAP(v1, v3); MEDIAN_SWAP(v2, v4);
    MEDIAN_SWAP(v3, v5); MEDIAN_SWAP(v2, v3);
    return v3;
}

float median9(float v0,float v1,float v2,float v3,float v4,float v5,float v6,float v7,float v8) {
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v4, v5); MEDIAN_SWAP(v7, v8);
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v6, v7);
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v4, v5); MEDIAN_SWAP(v7, v8);
    MEDIAN_SWAP(v0, v3); MEDIAN_SWAP(v5, v8); MEDIAN_SWAP(v4, v7);
    MEDIAN_SWAP(v3, v6); MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v2, v5);
    MEDIAN_SWAP(v4, v7); MEDIAN_SWAP(v4, v2); MEDIAN_SWAP(v6, v4);
    MEDIAN_SWAP(v4, v2);
    return v4;
}

float4 PSMedianFiltering(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float final_median;

	if (kernelSize == 1) {
		final_median = image.Sample(def_sampler, uv).r;
	} else if (kernelSize == 3) {
		int radius = 1;
		float p[9];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*3 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[3];
		for (int i = 0; i < 3; i++) {
			h_medians[i] = median3(p[i*3+0], p[i*3+1], p[i*3+2]);
		}
		final_median = median3(h_medians[0], h_medians[1], h_medians[2]);
	} else if (kernelSize == 5) {
		int radius = 2;
		float p[25];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*5 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[5];
		for (int i = 0; i < 5; i++) {
			h_medians[i] = median5(p[i*5+0], p[i*5+1], p[i*5+2], p[i*5+3], p[i*5+4]);
		}
		final_median = median5(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4]);
	} else if (kernelSize == 7) {
		int radius = 3;
		float p[49];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*7 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[7];
		for (int i = 0; i < 7; i++) {
			h_medians[i] = median7(p[i*7+0], p[i*7+1], p[i*7+2], p[i*7+3], p[i*7+4], p[i*7+5], p[i*7+6]);
		}
		final_median = median7(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4], h_medians[5], h_medians[6]);
	} else if (kernelSize == 9) {
		int radius = 4;
		float p[81];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*9 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[9];
		for (int i = 0; i < 9; i++) {
			h_medians[i] = median9(p[i*9+0], p[i*9+1], p[i*9+2], p[i*9+3], p[i*9+4], p[i*9+5], p[i*9+6], p[i*9+7], p[i*9+8]);
		}
		final_median = median9(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4], h_medians[5], h_medians[6], h_medians[7], h_medians[8]);
	} else {
		return image.Sample(def_sampler, vert_in.uv);
	}

	return float4(final_median, final_median, final_median, 1.0);
}

float4 PSCalculateMotionMap(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float sad = 0.0;
	int radius = kernelSize / 2;

	for (int y = -radius; y <= radius; y++) {
		for (int x = -radius; x <= radius; x++) {
			float luma = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			float luma1 = image1.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			sad += abs(luma - luma1);
		}
	}

	sad /= float(kernelSize * kernelSize);

	return float4(sad, sad, sad, 1.0);
}

float4 PSMotionAdaptiveFiltering(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	float luma1 = image1.Sample(def_sampler, vert_in.uv).r;
	float diff = abs(luma - luma1);
	float motionFactor = smoothstep(0.0, motionThreshold, diff);
	float blendFactor = strength * motionFactor;
	float finalLuma = lerp(luma1, luma, blendFactor);
	return float4(finalLuma, finalLuma, finalLuma, 1.0);
}

float4 PSApplySobel(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float luma[9];
	luma[0] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, -1.0f)).r;
	luma[1] = image.Sample(def_sampler, uv + texel_size * float2( 0.0f, -1.0f)).r;
	luma[2] = image.Sample(def_sampler, uv + texel_size * float2( 1.0f, -1.0f)).r;
	luma[3] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f,  0.0f)).r;
	luma[4] = image.Sample(def_sampler, uv).r;
	luma[5] = image.Sample(def_sampler, uv + texel_size * float2( 1.0f,  0.0f)).r;
	luma[6] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f,  1.0f)).r;
	luma[7] = image.Sample(def_sampler, uv + texel_size * float2( 0.0f,  1.0f)).r;
	luma[8] = image.Sample(def_sampler, uv + texel_size * float2( 1.0f,  1.0f)).r;

	float sobelX = -luma[0] - 2.0f * luma[3] - luma[6] + luma[2] + 2.0f * luma[5] + luma[8];
	float sobelY = -luma[0] - 2.0f * luma[1] - luma[2] + luma[6] + 2.0f * luma[7] + luma[8];

	float magnitude = sqrt(sobelX * sobelX + sobelY * sobelY);

	return float4(magnitude / SQRT_20, sobelX / 8.0f + 0.5f, sobelY / 8.0f + 0.5f, 1.0f);
}

float4 PSSuppressNonMaximum(VertInOut vert_in) : TARGET
{
	float4 encoded = image.Sample(def_sampler, vert_in.uv);
	float encoded_magnitude = encoded.r;
	float gx = (encoded.g - 0.5f) * 8.0f;
	float gy = (encoded.b - 0.5f) * 8.0f;

	float2 offset = float2(0.0f, 0.0f);
	float gx_abs = abs(gx);
	float gy_abs = abs(gy);

	if (gy_abs < gx_abs * TAN_22_5) {
		offset = float2(texelWidth, 0.0f);
	} else if (gy_abs > gx_abs * TAN_67_5) {
		offset = float2(0.0f, texelHeight);
	} else {
		offset = float2(texelWidth, texelHeight);
		if ((gx > 0.0f && gy < 0.0f) || (gx < 0.0f && gy > 0.0f)) {
			offset.y = -1.0f;
		}
	}

	float neighbor_encoded_magnitude1 = image.Sample(def_sampler, vert_in.uv + offset).r;
	float neighbor_encoded_magnitude2 = image.Sample(def_sampler, vert_in.uv - offset).r;

	if (encoded_magnitude < neighbor_encoded_magnitude1 || encoded_magnitude < neighbor_encoded_magnitude2)
	{
		encoded_magnitude = 0.0f;
	}

	return float4(encoded_magnitude, encoded_magnitude, encoded_magnitude, 1.0f);
}

float4 PSHysteresisClassify(VertInOut vert_in) : TARGET
{
	float encoded_magnitude = image.Sample(def_sampler, vert_in.uv).r;

	if (encoded_magnitude >= highThreshold / SQRT_20) {
		return float4(1.0, 1.0, 1.0, 1.0);
	} else if (encoded_magnitude >= lowThreshold / SQRT_20) {
		return float4(0.5, 0.5, 0.5, 1.0);
	} else {
		return float4(0.0, 0.0, 0.0, 1.0);
	}
}

float4 PSHysteresisPropagate(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float center_val = image.Sample(def_sampler, uv).r;

	if (center_val < 0.5f || center_val == 1.0f) {
		return float4(center_val, center_val, center_val, 1.0f);
	}

	for (int y = -1; y <= 1; y++) {
		for (int x = -1; x <= 1; x++) {
			if (x == 0 && y == 0) continue;
			float neighbor_val = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
		        if (neighbor_val == 1.0f) {
        			return float4(1.0, 1.0, 1.0, 1.0);
        		}
		}
	}
    
	return float4(center_val, center_val, center_val, 1.0f);
}

float4 PSHysteresisFinalize(VertInOut vert_in) : TARGET
{
	float val = image.Sample(def_sampler, vert_in.uv).r;
    
	if (val < 1.0f) {
		return float4(0.0f, 0.0f, 0.0f, 1.0f);
	}

	return float4(1.0f, 1.0f, 1.0f, 1.0f);
}

float4 PSErosion(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float min_val = 1.0;
	int radius = kernelSize / 2;

	if (radius > 0) {
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				min_val = min(min_val, image.Sample(def_sampler, uv + texel_size * float2(x, y)).r);
			}
		}
	} else {
		min_val = image.Sample(def_sampler, uv).r;
	}

	return float4(min_val, min_val, min_val, 1.0);
}

float4 PSDilation(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float max_val = 0.0;
	int radius = kernelSize / 2;

	if (radius > 0) {
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				max_val = max(max_val, image.Sample(def_sampler, uv + texel_size * float2(x, y)).r);
			}
		}
	} else {
		max_val = image.Sample(def_sampler, uv).r;
	}

	return float4(max_val, max_val, max_val, 1.0);
}

float4 PSScaling(VertInOut vert_in) : TARGET
{
	return float4(image.Sample(def_sampler, vert_in.uv).rgb * scalingFactor, 1.0);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDraw(vert_in);
	}
}

technique ExtractLuminance
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSExtractLuminance(vert_in);
	}
}

technique MedianFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSMedianFiltering(vert_in);
	}
}

technique CalculateMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSCalculateMotionMap(vert_in);
	}
}

technique MotionAdaptiveFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSMotionAdaptiveFiltering(vert_in);
	}
}

technique ApplySobel
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSApplySobel(vert_in);
	}
}

technique SuppressNonMaximum
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSSuppressNonMaximum(vert_in);
	}
}

technique HysteresisClassify
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSHysteresisClassify(vert_in);
	}
}

technique HysteresisPropagate
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSHysteresisPropagate(vert_in);
	}
}

technique HysteresisFinalize
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSHysteresisFinalize(vert_in);
	}
}

technique Erosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSErosion(vert_in);
	}
}

technique Dilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDilation(vert_in);
	}
}

technique Scaling
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSScaling(vert_in);
	}
}
