uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d image1;

// Common parameters
uniform float texelWidth;
uniform float texelHeight;

// Motion adaptive filtering parameters
uniform texture2d motionMap;
uniform float strength;
uniform float motionThreshold;

// Sobel magnitude finalization parameter
uniform bool useLog;
uniform float scalingFactor;

// Canny edge detection parameters
uniform float highThreshold;
uniform float lowThreshold;

sampler_state def_sampler
{
	Filter = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertInOut {
	float4 pos : POSITION;
	float2 uv : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;
	return vert_out;
}

#include "drawing-pixelshaders.effect"

technique ConvertGrayscale
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSConvertGrayscale(vert_in);
	}
}

technique HorizontalMedian3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian3(vert_in);
	}
}

technique VerticalMedian3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian3(vert_in);
	}
}

technique CalculateHorizontalMotionMap3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateHorizontalMotionMap3(vert_in);
	}
}

technique CalculateVerticalMotionMap3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateVerticalMotionMap3(vert_in);
	}
}

technique MotionAdaptiveFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSMotionAdaptiveFiltering(vert_in);
	}
}

technique ApplySobel
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSApplySobel(vert_in);
	}
}

technique FinalizeSobelMagnitude
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSFinalizeSobelMagnitude(vert_in);
	}
}

technique HorizontalErosion3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalErosion3(vert_in);
	}
}

technique VerticalErosion3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalErosion3(vert_in);
	}
}

technique HorizontalDilation3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalDilation3(vert_in);
	}
}

technique VerticalDilation3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalDilation3(vert_in);
	}
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDraw(vert_in);
	}
}

technique DrawGrayscale
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDrawGrayscale(vert_in);
	}
}
