uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d image1;

// Common parameters
uniform float texelWidth;
uniform float texelHeight;
uniform int kernelSize;

// Motion adaptive filtering parameters
uniform texture2d motionMap;
uniform float strength;
uniform float motionThreshold;

// Sobel magnitude finalization parameter
uniform bool useLog;
uniform float scalingFactor;

// Canny edge detection parameters
uniform float highThreshold;
uniform float lowThreshold;

#define PI 3.14159265359f
#define SQRT_20 4.472136f
#define TAN_22_5 0.41421356f
#define TAN_67_5 2.41421356f

sampler_state def_sampler
{
	Filter = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertInOut {
	float4 pos : POSITION;
	float2 uv : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;
	return vert_out;
}

//
// Role:      Simply draws the source texture.
// Prerequisite: Original Source (e.g., video input from OBS).
// Input:     The original color image from the 'image' texture.
// Uniforms:  None.
// Output:    The same color image as the input.
//
float4 PSDraw(VertInOut vert_in) : TARGET
{
	return float4(0.5, 0.0, 0.0, 1.0);
	//return image.Sample(def_sampler, vert_in.uv);
}

//
// Role:      Converts a color image to a grayscale luminance map. This is the starting point for most subsequent operations.
// Prerequisite: Original Source (e.g., video input from OBS).
// Input:     The original color image from the 'image' texture.
// Uniforms:  None.
// Output:    A grayscale image with the luminance value stored in the .rgb channels (r=g=b).
//
float4 PSExtractLuminance(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(def_sampler, vert_in.uv);
	float luma = saturate(dot(color.rgb, float3(0.299, 0.587, 0.114)));
	return float4(luma, luma, luma, 1.0);
}

#define MEDIAN_SWAP(a, b) { float temp=a; a=min(a,b); b=max(temp,b); }

float median3(float v0, float v1, float v2)
{
	float a = min(v0, v1);
	float b = max(v0, v1);
	return max(a, min(b, v2));
}

float median5(float v0, float v1, float v2, float v3, float v4)
{
	MEDIAN_SWAP(v0, v1);
	MEDIAN_SWAP(v3, v4);
	MEDIAN_SWAP(v0, v3);
	MEDIAN_SWAP(v1, v4);
	MEDIAN_SWAP(v1, v2);
	MEDIAN_SWAP(v2, v3);
	MEDIAN_SWAP(v1, v2);
	return v2;
}

float median7(float v0, float v1, float v2, float v3, float v4, float v5, float v6)
{
	MEDIAN_SWAP(v1, v2);
	MEDIAN_SWAP(v3, v4);
	MEDIAN_SWAP(v5, v6);
	MEDIAN_SWAP(v0, v1);
	MEDIAN_SWAP(v2, v3);
	MEDIAN_SWAP(v4, v5);
	MEDIAN_SWAP(v1, v2);
	MEDIAN_SWAP(v3, v4);
	MEDIAN_SWAP(v5, v6);
	MEDIAN_SWAP(v0, v3);
	MEDIAN_SWAP(v1, v4);
	MEDIAN_SWAP(v2, v5);
	MEDIAN_SWAP(v3, v6);
	MEDIAN_SWAP(v1, v3);
	MEDIAN_SWAP(v2, v4);
	MEDIAN_SWAP(v3, v5);
	MEDIAN_SWAP(v2, v3);
	return v3;
}

float median9(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float v8)
{
	MEDIAN_SWAP(v1, v2);
	MEDIAN_SWAP(v4, v5);
	MEDIAN_SWAP(v7, v8);
	MEDIAN_SWAP(v0, v1);
	MEDIAN_SWAP(v3, v4);
	MEDIAN_SWAP(v6, v7);
	MEDIAN_SWAP(v1, v2);
	MEDIAN_SWAP(v4, v5);
	MEDIAN_SWAP(v7, v8);
	MEDIAN_SWAP(v0, v3);
	MEDIAN_SWAP(v5, v8);
	MEDIAN_SWAP(v4, v7);
	MEDIAN_SWAP(v3, v6);
	MEDIAN_SWAP(v1, v4);
	MEDIAN_SWAP(v2, v5);
	MEDIAN_SWAP(v4, v7);
	MEDIAN_SWAP(v4, v2);
	MEDIAN_SWAP(v6, v4);
	MEDIAN_SWAP(v4, v2);
	return v4;
}

//==================================================================================
// Separable Median Filter - Horizontal Pass
//==================================================================================

//
// Role:      [Separable Pass 1/2] Applies a 1D horizontal median filter. This is the
//            first pass of a two-pass separable median filter used to reduce noise.
// Prerequisite: A grayscale image (e.g., a luminance map).
// Input:     A single-channel image from 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate image with horizontal medians applied, intended for the vertical pass.
//
float4 PSHorizontalMedian3(VertInOut vert_in) : TARGET
{
	float samples[3];
	float2 texelStep = float2(texelWidth, 0.0f);
	float2 startUV = vert_in.uv - texelStep * 1;
	for (int i = 0; i < 3; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median3(samples[0], samples[1], samples[2]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

float4 PSHorizontalMedian5(VertInOut vert_in) : TARGET
{
	float samples[5];
	float2 texelStep = float2(texelWidth, 0.0f);
	float2 startUV = vert_in.uv - texelStep * 2;
	for (int i = 0; i < 5; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median5(samples[0], samples[1], samples[2], samples[3], samples[4]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

float4 PSHorizontalMedian7(VertInOut vert_in) : TARGET
{
	float samples[7];
	float2 texelStep = float2(texelWidth, 0.0f);
	float2 startUV = vert_in.uv - texelStep * 3;
	for (int i = 0; i < 7; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median7(samples[0], samples[1], samples[2], samples[3], samples[4], samples[5], samples[6]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

float4 PSHorizontalMedian9(VertInOut vert_in) : TARGET
{
	float samples[9];
	float2 texelStep = float2(texelWidth, 0.0f);
	float2 startUV = vert_in.uv - texelStep * 4;
	for (int i = 0; i < 9; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median9(samples[0], samples[1], samples[2], samples[3], samples[4], samples[5], samples[6],
				    samples[7], samples[8]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

//==================================================================================
// Separable Median Filter - Vertical Pass
//==================================================================================

//
// Role:      [Separable Pass 2/2] Applies a 1D vertical median filter on the result
//            of the horizontal pass to complete the noise reduction.
// Prerequisite: The intermediate texture generated by the corresponding horizontal median pass.
// Input:     An intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final median-filtered grayscale image.
//
float4 PSVerticalMedian3(VertInOut vert_in) : TARGET
{
	float samples[3];
	float2 texelStep = float2(0.0f, texelHeight);
	float2 startUV = vert_in.uv - texelStep * 1;
	for (int i = 0; i < 3; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median3(samples[0], samples[1], samples[2]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

float4 PSVerticalMedian5(VertInOut vert_in) : TARGET
{
	float samples[5];
	float2 texelStep = float2(0.0f, texelHeight);
	float2 startUV = vert_in.uv - texelStep * 2;
	for (int i = 0; i < 5; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median5(samples[0], samples[1], samples[2], samples[3], samples[4]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

float4 PSVerticalMedian7(VertInOut vert_in) : TARGET
{
	float samples[7];
	float2 texelStep = float2(0.0f, texelHeight);
	float2 startUV = vert_in.uv - texelStep * 3;
	for (int i = 0; i < 7; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median7(samples[0], samples[1], samples[2], samples[3], samples[4], samples[5], samples[6]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

float4 PSVerticalMedian9(VertInOut vert_in) : TARGET
{
	float samples[9];
	float2 texelStep = float2(0.0f, texelHeight);
	float2 startUV = vert_in.uv - texelStep * 4;
	for (int i = 0; i < 9; ++i) {
		samples[i] = image.Sample(def_sampler, startUV + texelStep * i).r;
	}
	float medianValue = median9(samples[0], samples[1], samples[2], samples[3], samples[4], samples[5], samples[6],
				    samples[7], samples[8]);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

//
// Role:      Calculates a motion map by comparing two frames to detect areas of movement.
// Prerequisite: Two separate luminance maps (e.g., from two PSExtractLuminance passes on different frames).
// Input:     'image.r' (current frame luminance), 'image1.r' (previous frame luminance).
// Uniforms:  kernelSize, texelWidth, texelHeight.
// Output:    A motion map with the amount of motion (SAD: Sum of Absolute Differences) in the .rgb channels.
//
float4 PSCalculateMotionMap(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float mad = 0.0;
	int radius = kernelSize / 2;

	for (int y = -radius; y <= radius; y++) {
		for (int x = -radius; x <= radius; x++) {
			float luma = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			float luma1 = image1.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			mad += abs(luma - luma1);
		}
	}

	mad = saturate(mad / float(kernelSize * kernelSize));

	return float4(mad, mad, mad, 1.0);
}

//
// Role:      [Separable Pass 1/2] Calculates the HORIZONTAL AVERAGE of absolute differences
//            for the motion map.
// Prerequisite: Two separate luminance maps (current and previous frames).
// Input:     'image.r' (current frame luminance), 'image1.r' (previous frame luminance).
// Uniforms:  kernelSize, texelWidth.
// Output:    The horizontal average of absolute differences, stored in .rgb.
//            NOTE: This output is normalized by the kernel width and is safely within [0,1].
//
float4 PSCalculateHorizontalMotionMap(VertInOut vert_in) : TARGET
{
        float2 texel_step = float2(texelWidth, 0.0f);
        float2 uv = vert_in.uv;
        
        float h_sad = 0.0;
        int radius = kernelSize / 2;
        float2 start_uv = uv - texel_step * radius;

        for (int x = 0; x < kernelSize; x++) {
                float2 current_uv = start_uv + texel_step * x;
                float luma  = image.Sample(def_sampler, current_uv).r;
                float luma1 = image1.Sample(def_sampler, current_uv).r;
                h_sad += abs(luma - luma1);
        }

        float h_aad = saturate(h_sad / float(kernelSize));

        return float4(h_aad, h_aad, h_aad, 1.0);
}

//
// Role:      [Separable Pass 2/2] Calculates the VERTICAL AVERAGE of the horizontal
//            averages to finalize the motion map.
// Prerequisite: The intermediate texture generated by the horizontal pass.
// Input:     'image.r' (The result from the horizontal pass, i.e., horizontal averages).
// Uniforms:  kernelSize, texelHeight.
// Output:    The final, normalized motion map.
//
float4 PSCalculateVerticalMotionMap(VertInOut vert_in) : TARGET
{
        float2 texel_step = float2(0.0f, texelHeight);
        float2 uv = vert_in.uv;

        float total_aad = 0.0;
        int radius = kernelSize / 2;
        float2 start_uv = uv - texel_step * radius;
        
        for (int y = 0; y < kernelSize; y++) {
                float2 current_uv = start_uv + texel_step * y;
                float h_aad = image.Sample(def_sampler, current_uv).r;
                total_aad += h_aad;
        }

        float final_aad = saturate(total_aad / float(kernelSize));

        return float4(final_aad, final_aad, final_aad, 1.0);
}

//
// Role:      Performs motion-adaptive temporal filtering by blending the current frame
//            with the previous frame, using a pre-calculated motion map to control
//            the blend strength. This is highly effective for reducing noise in
//            static or low-motion areas of a video stream.
// Prerequisite: Requires a motion map, typically generated by the 'PSCalculateMotionMap'
//               pass, along with the current and previous frames.
// Input:     'image.r': The current (potentially noisy) grayscale frame.
//            'image1.r': The previously filtered grayscale frame (temporal accumulator).
//            'motionMap.r': A map where pixel intensity indicates the amount of motion.
// Uniforms:  strength, motionThreshold.
// Output:    A grayscale image with temporal noise reduction applied, stored in .rgb.
//
float4 PSMotionAdaptiveFiltering(VertInOut vert_in) : TARGET
{
        float luma = image.Sample(def_sampler, vert_in.uv).r;
        float luma1 = image1.Sample(def_sampler, vert_in.uv).r;
        float motion = motionMap.Sample(def_sampler, vert_in.uv).r;
        float motionFactor = smoothstep(0.0, motionThreshold, motion);
        float blendFactor = strength * motionFactor;
        float finalLuma = lerp(luma1, luma, blendFactor);
        return float4(finalLuma, finalLuma, finalLuma, 1.0);
}

//
// Role:      [Canny Step 1] Applies the Sobel operator to calculate the gradient magnitude and direction.
// Prerequisite: PSExtractLuminance or PSMedianFiltering.
// Input:     A grayscale image in 'image.r'.
// Uniforms:  texelWidth, texelHeight.
// Output:    .r = Gradient Magnitude (normalized), .g = Gx (encoded to [0,1]), .b = Gy (encoded to [0,1]).
//
float4 PSApplySobel(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float luma[9];
	luma[0] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, -1.0f)).r;
	luma[1] = image.Sample(def_sampler, uv + texel_size * float2(0.0f, -1.0f)).r;
	luma[2] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, -1.0f)).r;
	luma[3] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, 0.0f)).r;
	luma[4] = image.Sample(def_sampler, uv).r;
	luma[5] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, 0.0f)).r;
	luma[6] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, 1.0f)).r;
	luma[7] = image.Sample(def_sampler, uv + texel_size * float2(0.0f, 1.0f)).r;
	luma[8] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, 1.0f)).r;

	float gx = -luma[0] - 2.0f * luma[3] - luma[6] + luma[2] + 2.0f * luma[5] + luma[8];
	float gy = -luma[0] - 2.0f * luma[1] - luma[2] + luma[6] + 2.0f * luma[7] + luma[8];
	float magnitude = sqrt(gx * gx + gy * gy);

	// Normalize by a typical maximum gradient magnitude
	magnitude = saturate(magnitude / SQRT_20);
	gx = saturate(gx / 8.0f + 0.5f);
	gy = saturate(gy / 8.0f + 0.5f);

	return float4(magnitude, gx, gy, 1.0f);
}

//
// Role:      Adjusts the gradient magnitude with a scaling factor or logarithmic transformation.
// Prerequisite: PSSuppressNonMaximum (or any other shader that outputs a grayscale magnitude).
// Input:     A gradient magnitude in 'image.r'.
// Uniforms:  useLog, scalingFactor.
// Output:    A grayscale image with the adjusted magnitude in the .rgb channels.
//
float4 PSFinalizeSobelMagnitude(VertInOut vert_in) : TARGET
{
	float magnitude = image.Sample(def_sampler, vert_in.uv).r;
	if (useLog) {
		magnitude = log(1.0f + magnitude) / log(2.0f);
	}
	magnitude = saturate(magnitude * scalingFactor);
	return float4(magnitude, magnitude, magnitude, 1.0f);
}

//
// Role:      [Canny Step 2] Performs non-maximum suppression to thin edges.
// Prerequisite: PSApplySobel.
// Input:     Encoded Sobel data from 'image' (.r=Magnitude, .g=Gx, .b=Gy).
// Uniforms:  texelWidth, texelHeight.
// Output:    A grayscale image with thinned edges in the .rgb channels. Non-maximal pixels are set to 0.
//
float4 PSSuppressNonMaximum(VertInOut vert_in) : TARGET
{
	float4 encoded = image.Sample(def_sampler, vert_in.uv);
	float encoded_magnitude = encoded.r;
	float gx = (encoded.g - 0.5f) * 8.0f;
	float gy = (encoded.b - 0.5f) * 8.0f;

	float2 offset = float2(0.0f, 0.0f);
	float gx_abs = abs(gx);
	float gy_abs = abs(gy);

	if (gy_abs < gx_abs * TAN_22_5) {
		offset = float2(texelWidth, 0.0f);
	} else if (gy_abs > gx_abs * TAN_67_5) {
		offset = float2(0.0f, texelHeight);
	} else {
		offset = float2(texelWidth, texelHeight);
		// If gradient is in the 2nd or 4th quadrant (e.g., top-right to bottom-left edge),
		// flip the y-component of the offset.
		if ((gx > 0.0f && gy < 0.0f) || (gx < 0.0f && gy > 0.0f)) {
			offset.y = -texelHeight;
		}
	}

	float neighbor_encoded_magnitude1 = image.Sample(def_sampler, vert_in.uv + offset).r;
	float neighbor_encoded_magnitude2 = image.Sample(def_sampler, vert_in.uv - offset).r;

	if (encoded_magnitude < neighbor_encoded_magnitude1 || encoded_magnitude < neighbor_encoded_magnitude2) {
		encoded_magnitude = 0.0f;
	}

	return float4(encoded_magnitude, encoded_magnitude, encoded_magnitude, 1.0f);
}

//
// Role:      [Canny Step 3] Classifies pixels into strong (1.0), weak (0.5), or non-edges (0.0) using two thresholds.
// Prerequisite: PSSuppressNonMaximum (or PSFinalizeSobelMagnitude if it was used for adjustment).
// Input:     A thinned, grayscale edge map in 'image.r'.
// Uniforms:  highThreshold, lowThreshold.
// Output:    A classification map in the .rgb channels (1.0 for strong, 0.5 for weak, 0.0 for non-edge).
//
float4 PSHysteresisClassify(VertInOut vert_in) : TARGET
{
	float encoded_magnitude = image.Sample(def_sampler, vert_in.uv).r;

	if (encoded_magnitude >= highThreshold) {
		return float4(1.0, 1.0, 1.0, 1.0);
	} else if (encoded_magnitude >= lowThreshold) {
		return float4(0.5, 0.5, 0.5, 1.0);
	} else {
		return float4(0.0, 0.0, 0.0, 1.0);
	}
}

//
// Role:      [Canny Step 4] Connects edges by promoting weak edges (0.5) to strong ones (1.0) if they are adjacent to a strong edge.
// Prerequisite: PSHysteresisClassify.
// Input:     A classification map in 'image.r'.
// Uniforms:  texelWidth, texelHeight.
// Output:    An updated classification map in the .rgb channels.
//
float4 PSHysteresisPropagate(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float center_val = image.Sample(def_sampler, uv).r;

	if (center_val < 0.5f || center_val == 1.0f) {
		return float4(center_val, center_val, center_val, 1.0f);
	}

	for (int y = -1; y <= 1; y++) {
		for (int x = -1; x <= 1; x++) {
			if (x == 0 && y == 0)
				continue;
			float neighbor_val = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			if (neighbor_val == 1.0f) {
				return float4(1.0, 1.0, 1.0, 1.0);
			}
		}
	}

	return float4(center_val, center_val, center_val, 1.0f);
}

//
// Role:      [Canny Step 5] Finalizes the edge map by removing any remaining weak edges.
// Prerequisite: PSHysteresisPropagate.
// Input:     A propagated classification map in 'image.r'.
// Uniforms:  None.
// Output:    The final binary edge map in the .rgb channels (1.0 for edges, 0.0 for non-edges).
//
float4 PSHysteresisFinalize(VertInOut vert_in) : TARGET
{
	float val = image.Sample(def_sampler, vert_in.uv).r;

	if (val < 1.0f) {
		return float4(0.0f, 0.0f, 0.0f, 1.0f);
	}

	return float4(1.0f, 1.0f, 1.0f, 1.0f);
}

//==================================================================================
// Separable Erosion
//==================================================================================

//
// Role:      [Separable Pass 1/2] Performs HORIZONTAL morphological erosion.
// Prerequisite: A single-channel image (e.g., a binary edge map).
// Input:     A single-channel image in 'image.r'.
// Uniforms:  kernelSize, texelWidth.
// Output:    An intermediate texture with horizontal erosion applied.
//
float4 PSHorizontalErosion(VertInOut vert_in) : TARGET
{
        float2 texel_step = float2(texelWidth, 0.0f);
        float2 uv = vert_in.uv;
        float min_val = 1.0;
        int radius = kernelSize / 2;
        float2 start_uv = uv - texel_step * radius;

        for (int x = 0; x < kernelSize; x++) {
                min_val = min(min_val, image.Sample(def_sampler, start_uv + texel_step * x).r);
        }

        return float4(min_val, min_val, min_val, 1.0);
}

//
// Role:      [Separable Pass 2/2] Performs VERTICAL morphological erosion on the
//            result of the horizontal pass.
// Prerequisite: The intermediate texture from the horizontal erosion pass.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  kernelSize, texelHeight.
// Output:    The final eroded grayscale image.
//
float4 PSVerticalErosion(VertInOut vert_in) : TARGET
{
        float2 texel_step = float2(0.0f, texelHeight);
        float2 uv = vert_in.uv;
        float min_val = 1.0;
        int radius = kernelSize / 2;
        float2 start_uv = uv - texel_step * radius;

        for (int y = 0; y < kernelSize; y++) {
                min_val = min(min_val, image.Sample(def_sampler, start_uv + texel_step * y).r);
        }

        return float4(min_val, min_val, min_val, 1.0);
}


//==================================================================================
// Separable Dilation
//==================================================================================

//
// Role:      [Separable Pass 1/2] Performs HORIZONTAL morphological dilation.
// Prerequisite: A single-channel image (e.g., a binary edge map).
// Input:     A single-channel image in 'image.r'.
// Uniforms:  kernelSize, texelWidth.
// Output:    An intermediate texture with horizontal dilation applied.
//
float4 PSHorizontalDilation(VertInOut vert_in) : TARGET
{
        float2 texel_step = float2(texelWidth, 0.0f);
        float2 uv = vert_in.uv;
        float max_val = 0.0;
        int radius = kernelSize / 2;
        float2 start_uv = uv - texel_step * radius;

        for (int x = 0; x < kernelSize; x++) {
                max_val = max(max_val, image.Sample(def_sampler, start_uv + texel_step * x).r);
        }

        return float4(max_val, max_val, max_val, 1.0);
}

//
// Role:      [Separable Pass 2/2] Performs VERTICAL morphological dilation on the
//            result of the horizontal pass.
// Prerequisite: The intermediate texture from the horizontal dilation pass.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  kernelSize, texelHeight.
// Output:    The final dilated grayscale image.
//
float4 PSVerticalDilation(VertInOut vert_in) : TARGET
{
        float2 texel_step = float2(0.0f, texelHeight);
        float2 uv = vert_in.uv;
        float max_val = 0.0;
        int radius = kernelSize / 2;
        float2 start_uv = uv - texel_step * radius;

        for (int y = 0; y < kernelSize; y++) {
                max_val = max(max_val, image.Sample(def_sampler, start_uv + texel_step * y).r);
        }

        return float4(max_val, max_val, max_val, 1.0);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSDraw(vert_in);
	}
}

technique ExtractLuminance
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSExtractLuminance(vert_in);
	}
}

technique HorizontalMedian3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian3(vert_in);
	}
}

technique HorizontalMedian5
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian5(vert_in);
	}
}

technique HorizontalMedian7
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian7(vert_in);
	}
}

technique HorizontalMedian9
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalMedian9(vert_in);
	}
}

technique VerticalMedian3
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian3(vert_in);
	}
}

technique VerticalMedian5
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian5(vert_in);
	}
}

technique VerticalMedian7
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian7(vert_in);
	}
}

technique VerticalMedian9
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalMedian9(vert_in);
	}
}

technique CalculateHorizontalMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateHorizontalMotionMap(vert_in);
	}
}

technique CalculateVerticalMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSCalculateVerticalMotionMap(vert_in);
	}
}

technique MotionAdaptiveFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSMotionAdaptiveFiltering(vert_in);
	}
}

technique ApplySobel
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSApplySobel(vert_in);
	}
}

technique FinalizeSobelMagnitude
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSFinalizeSobelMagnitude(vert_in);
	}
}

technique SuppressNonMaximum
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSSuppressNonMaximum(vert_in);
	}
}

technique HysteresisClassify
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHysteresisClassify(vert_in);
	}
}

technique HysteresisPropagate
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHysteresisPropagate(vert_in);
	}
}

technique HysteresisFinalize
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHysteresisFinalize(vert_in);
	}
}

technique HorizontalErosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalErosion(vert_in);
	}
}

technique VerticalErosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalErosion(vert_in);
	}
}

technique HorizontalDilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSHorizontalDilation(vert_in);
	}
}

technique VerticalDilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader = PSVerticalDilation(vert_in);
	}
}
