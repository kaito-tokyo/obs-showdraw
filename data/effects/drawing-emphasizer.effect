uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d image1;

// Common parameters
uniform float texelWidth;
uniform float texelHeight;
uniform int kernelSize;

// Motion adaptive filtering parameters
uniform texture2d motionMap;
uniform float strength;
uniform float motionThreshold;

// Scaling parameters
uniform float scalingFactor;

sampler_state def_sampler {
	Filter   = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertInOut {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
	VertInOut vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = vert_in.uv;
	return vert_out;
}

float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(def_sampler, vert_in.uv);
}

float4 PSExtractLuminance(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(def_sampler, vert_in.uv);
	float luma = saturate(dot(color.rgb, float3(0.299, 0.587, 0.114)));
	return float4(luma, luma, luma, 1.0);
}

#define MEDIAN_SWAP(a,b) { float temp=a; a=min(a,b); b=max(temp,b); }

float median3(float v0, float v1, float v2) {
    float a = min(v0, v1);
    float b = max(v0, v1);
    return max(a, min(b, v2));}

float median5(float v0, float v1, float v2, float v3, float v4) {
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v0, v3);
    MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v2, v3);
    MEDIAN_SWAP(v1, v2);
    return v2;
}

float median7(float v0, float v1, float v2, float v3, float v4, float v5, float v6) {
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v5, v6);
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v2, v3); MEDIAN_SWAP(v4, v5);
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v5, v6);
    MEDIAN_SWAP(v0, v3); MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v2, v5);
    MEDIAN_SWAP(v3, v6); MEDIAN_SWAP(v1, v3); MEDIAN_SWAP(v2, v4);
    MEDIAN_SWAP(v3, v5); MEDIAN_SWAP(v2, v3);
    return v3;
}

float median9(float v0,float v1,float v2,float v3,float v4,float v5,float v6,float v7,float v8) {
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v4, v5); MEDIAN_SWAP(v7, v8);
    MEDIAN_SWAP(v0, v1); MEDIAN_SWAP(v3, v4); MEDIAN_SWAP(v6, v7);
    MEDIAN_SWAP(v1, v2); MEDIAN_SWAP(v4, v5); MEDIAN_SWAP(v7, v8);
    MEDIAN_SWAP(v0, v3); MEDIAN_SWAP(v5, v8); MEDIAN_SWAP(v4, v7);
    MEDIAN_SWAP(v3, v6); MEDIAN_SWAP(v1, v4); MEDIAN_SWAP(v2, v5);
    MEDIAN_SWAP(v4, v7); MEDIAN_SWAP(v4, v2); MEDIAN_SWAP(v6, v4);
    MEDIAN_SWAP(v4, v2);
    return v4;
}

float4 PSMedianFiltering(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float final_median;

	if (kernelSize == 1) {
		final_median = image.Sample(def_sampler, uv).r;
	} else if (kernelSize == 3) {
		int radius = 1;
		float p[9];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*3 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[3];
		for (int i = 0; i < 3; i++) {
			h_medians[i] = median3(p[i*3+0], p[i*3+1], p[i*3+2]);
		}
		final_median = median3(h_medians[0], h_medians[1], h_medians[2]);
	} else if (kernelSize == 5) {
		int radius = 2;
		float p[25];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*5 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[5];
		for (int i = 0; i < 5; i++) {
			h_medians[i] = median5(p[i*5+0], p[i*5+1], p[i*5+2], p[i*5+3], p[i*5+4]);
		}
		final_median = median5(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4]);
	} else if (kernelSize == 7) {
		int radius = 3;
		float p[49];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*7 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[7];
		for (int i = 0; i < 7; i++) {
			h_medians[i] = median7(p[i*7+0], p[i*7+1], p[i*7+2], p[i*7+3], p[i*7+4], p[i*7+5], p[i*7+6]);
		}
		final_median = median7(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4], h_medians[5], h_medians[6]);
	} else if (kernelSize == 9) {
		int radius = 4;
		float p[81];
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				p[(y+radius)*9 + (x+radius)] = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			}
		}
		float h_medians[9];
		for (int i = 0; i < 9; i++) {
			h_medians[i] = median9(p[i*9+0], p[i*9+1], p[i*9+2], p[i*9+3], p[i*9+4], p[i*9+5], p[i*9+6], p[i*9+7], p[i*9+8]);
		}
		final_median = median9(h_medians[0], h_medians[1], h_medians[2], h_medians[3], h_medians[4], h_medians[5], h_medians[6], h_medians[7], h_medians[8]);
	} else {
		return image.Sample(def_sampler, vert_in.uv);
	}

	return float4(final_median, final_median, final_median, 1.0);
}

float4 PSCalculateMotionMap(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float sad = 0.0;
	int radius = kernelSize / 2;

	for (int y = -radius; y <= radius; y++) {
		for (int x = -radius; x <= radius; x++) {
			float luma = image.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			float luma1 = image1.Sample(def_sampler, uv + texel_size * float2(x, y)).r;
			sad += abs(luma - luma1);
		}
	}

	sad /= float(kernelSize * kernelSize);

	return float4(sad, sad, sad, 1.0);
}

float4 PSMotionAdaptiveFiltering(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	float luma1 = image1.Sample(def_sampler, vert_in.uv).r;
	float diff = abs(luma - luma1);
	float motionFactor = smoothstep(0.0, motionThreshold, diff);
	float blendFactor = strength * motionFactor;
	float finalLuma = lerp(luma1, luma, blendFactor);
	return float4(finalLuma, finalLuma, finalLuma, 1.0);
}

float4 PSDetectEdge(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float lum[9];
	lum[0] = image.Sample(def_sampler, uv + texel_size * float2(-1.0, -1.0)).r;
	lum[1] = image.Sample(def_sampler, uv + texel_size * float2( 0.0, -1.0)).r;
	lum[2] = image.Sample(def_sampler, uv + texel_size * float2( 1.0, -1.0)).r;
	lum[3] = image.Sample(def_sampler, uv + texel_size * float2(-1.0,  0.0)).r;
	lum[4] = image.Sample(def_sampler, uv).r;
	lum[5] = image.Sample(def_sampler, uv + texel_size * float2( 1.0,  0.0)).r;
	lum[6] = image.Sample(def_sampler, uv + texel_size * float2(-1.0,  1.0)).r;
	lum[7] = image.Sample(def_sampler, uv + texel_size * float2( 0.0,  1.0)).r;
	lum[8] = image.Sample(def_sampler, uv + texel_size * float2( 1.0,  1.0)).r;

	float sobel_x = -lum[0] - 2.0 * lum[3] - lum[6] + lum[2] + 2.0 * lum[5] + lum[8];
	float sobel_y = -lum[0] - 2.0 * lum[1] - lum[2] + lum[6] + 2.0 * lum[7] + lum[8];

	float edge = sqrt(sobel_x * sobel_x + sobel_y * sobel_y);

	return float4(edge, edge, edge, 1.0);
}

float4 PSErosion(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float min_val = 1.0;
	int radius = kernelSize / 2;

	if (radius > 0) {
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				min_val = min(min_val, image.Sample(def_sampler, uv + texel_size * float2(x, y)).r);
			}
		}
	} else {
		min_val = image.Sample(def_sampler, uv).r;
	}

	return float4(min_val, min_val, min_val, 1.0);
}

float4 PSDilation(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;
	float max_val = 0.0;
	int radius = kernelSize / 2;

	if (radius > 0) {
		for (int y = -radius; y <= radius; y++) {
			for (int x = -radius; x <= radius; x++) {
				max_val = max(max_val, image.Sample(def_sampler, uv + texel_size * float2(x, y)).r);
			}
		}
	} else {
		max_val = image.Sample(def_sampler, uv).r;
	}

	return float4(max_val, max_val, max_val, 1.0);
}

float4 PSScaling(VertInOut vert_in) : TARGET
{
	return float4(image.Sample(def_sampler, vert_in.uv).rgb * scalingFactor, 1.0);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDraw(vert_in);
	}
}

technique ExtractLuminance
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSExtractLuminance(vert_in);
	}
}

technique MedianFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSMedianFiltering(vert_in);
	}
}

technique CalculateMotionMap
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSCalculateMotionMap(vert_in);
	}
}

technique MotionAdaptiveFiltering
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSMotionAdaptiveFiltering(vert_in);
	}
}

technique DetectEdge
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDetectEdge(vert_in);
	}
}

technique Erosion
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSErosion(vert_in);
	}
}

technique Dilation
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSDilation(vert_in);
	}
}

technique Scaling
{
	pass
	{
		vertex_shader = VSDefault(vert_in);
		pixel_shader  = PSScaling(vert_in);
	}
}
