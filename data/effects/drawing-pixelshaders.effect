#define SQRT_20 4.472136f

//
// Role:      Converts a color image to a grayscale luminance map. This is the first step for many image processing operations.
// Prerequisite: The original video source from OBS.
// Input:     A color image from the 'image' texture.
// Uniforms:  None.
// Output:    A grayscale image with the luminance value in the rgb channels (r=g=b).
//
float4 PSConvertGrayscale(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(def_sampler, vert_in.uv);
	float luma = saturate(dot(color.rgb, float3(0.2126, 0.7152, 0.0722)));
	return float4(luma, luma, luma, 1.0f);
}

float median3(float v0, float v1, float v2)
{
	float a = min(v0, v1);
	float b = max(v0, v1);
	return max(a, min(b, v2));
}

//
// Role:      [Separable Pass 1/2] Applies a 3x1 horizontal median filter. Used as a preprocessing step to reduce noise.
// Prerequisite: A grayscale image, e.g., from PSConvertGrayscale.
// Input:     A single-channel image from 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate image with horizontal median filtering applied, intended for the vertical pass.
//
float4 PSHorizontalMedian3(VertInOut vert_in) : TARGET
{
	float2 texelStep = float2(texelWidth, 0.0f);
	float s0 = image.Sample(def_sampler, vert_in.uv - texelStep).r;
	float s1 = image.Sample(def_sampler, vert_in.uv).r;
	float s2 = image.Sample(def_sampler, vert_in.uv + texelStep).r;
	float medianValue = median3(s0, s1, s2);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

//
// Role:      [Separable Pass 2/2] Applies a 1x3 vertical median filter to complete the two-pass noise reduction.
// Prerequisite: The intermediate image generated by PSHorizontalMedian3.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final grayscale image with median filter noise reduction applied.
//
float4 PSVerticalMedian3(VertInOut vert_in) : TARGET
{
	float2 texelStep = float2(0.0f, texelHeight);
	float s0 = image.Sample(def_sampler, vert_in.uv - texelStep).r;
	float s1 = image.Sample(def_sampler, vert_in.uv).r;
	float s2 = image.Sample(def_sampler, vert_in.uv + texelStep).r;
	float medianValue = median3(s0, s1, s2);
	return float4(medianValue, medianValue, medianValue, 1.0f);
}

//
// Role:      [Separable Pass 1/2] Calculates the horizontal average of absolute luminance differences between two frames to generate a motion map.
// Prerequisite: Two luminance maps generated from different frames.
// Input:     'image.r' (current frame luminance), 'image1.r' (previous frame luminance).
// Uniforms:  texelWidth.
// Output:    An intermediate image storing the horizontal average absolute difference.
//
float4 PSCalculateHorizontalMotionMap3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(texelWidth, 0.0f);
	float2 uv = vert_in.uv;

	float2 uv_prev = uv - texel_step;
	float2 uv_next = uv + texel_step;

	float sad = 0.0f;
	sad += abs(image.Sample(def_sampler, uv_prev).r - image1.Sample(def_sampler, uv_prev).r);
	sad += abs(image.Sample(def_sampler, uv).r - image1.Sample(def_sampler, uv).r);
	sad += abs(image.Sample(def_sampler, uv_next).r - image1.Sample(def_sampler, uv_next).r);

	float aad = saturate(sad / 3.0f);

	return float4(aad, aad, aad, 1.0);
}

//
// Role:      [Separable Pass 2/2] Calculates the vertical average of the horizontal average absolute differences to finalize the motion map.
// Prerequisite: The intermediate image generated by PSCalculateHorizontalMotionMap3.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final, normalized motion map.
//
float4 PSCalculateVerticalMotionMap3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(0.0f, texelHeight);
	float2 uv = vert_in.uv;

	float aad_prev = image.Sample(def_sampler, uv - texel_step).r;
	float aad_curr = image.Sample(def_sampler, uv).r;
	float aad_next = image.Sample(def_sampler, uv + texel_step).r;

	float total_aad = aad_prev + aad_curr + aad_next;
	float final_aad = saturate(total_aad / 3.0f);

	return float4(final_aad, final_aad, final_aad, 1.0);
}

//
// Role:      Performs temporal noise filtering using a motion map. Effectively reduces noise in static areas.
// Prerequisite: A motion map, the current frame, and the previous filtered frame.
// Input:     'image.r' (current frame), 'image1.r' (previous filtered result), 'motionMap.r' (amount of motion).
// Uniforms:  strength, motionThreshold.
// Output:    A grayscale image with temporal noise reduction applied.
//
float4 PSMotionAdaptiveFiltering(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	float luma1 = image1.Sample(def_sampler, vert_in.uv).r;
	float motion = motionMap.Sample(def_sampler, vert_in.uv).r;
	float motionFactor = smoothstep(0.0, motionThreshold, motion);
	float blendFactor = strength * motionFactor;
	float finalLuma = lerp(luma1, luma, blendFactor);
	return float4(finalLuma, finalLuma, finalLuma, 1.0);
}

//
// Role:      Applies the Sobel operator to detect edges in an image.
// Prerequisite: A grayscale image, e.g., from PSConvertGrayscale. For more stable results, smooth the image with a median filter beforehand.
// Input:     A grayscale image from 'image.r'.
// Output:    r = Edge Magnitude (normalized), g = Horizontal Gradient (Gx), b = Vertical Gradient (Gy).
//
float4 PSApplySobel(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float luma[9];
	luma[0] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, -1.0f)).r;
	luma[1] = image.Sample(def_sampler, uv + texel_size * float2(0.0f, -1.0f)).r;
	luma[2] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, -1.0f)).r;
	luma[3] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, 0.0f)).r;
	luma[4] = image.Sample(def_sampler, uv).r;
	luma[5] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, 0.0f)).r;
	luma[6] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, 1.0f)).r;
	luma[7] = image.Sample(def_sampler, uv + texel_size * float2(0.0f, 1.0f)).r;
	luma[8] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, 1.0f)).r;

	float gx = -luma[0] - 2.0f * luma[3] - luma[6] + luma[2] + 2.0f * luma[5] + luma[8];
	float gy = -luma[0] - 2.0f * luma[1] - luma[2] + luma[6] + 2.0f * luma[7] + luma[8];
	float magnitude = sqrt(gx * gx + gy * gy);

	magnitude = saturate(magnitude / SQRT_20);
	gx = saturate(gx / 8.0f + 0.5f);
	gy = saturate(gy / 8.0f + 0.5f);

	return float4(magnitude, gx, gy, 1.0f);
}

//
// Role:      Adjusts the contrast of the edge magnitude map obtained from the Sobel filter to finalize its appearance.
// Prerequisite: The output texture from PSApplySobel.
// Input:     An edge magnitude map from 'image.r'.
// Uniforms:  useLog, scalingFactor.
// Output:    A grayscale edge image with adjusted contrast.
//
float4 PSFinalizeSobelMagnitude(VertInOut vert_in) : TARGET
{
	float magnitude = image.Sample(def_sampler, vert_in.uv).r;
	if (useLog) {
		magnitude = log(1.0f + magnitude) / log(2.0f);
	}
	magnitude = saturate(magnitude * scalingFactor);
	return float4(magnitude, magnitude, magnitude, 1.0f);
}

//
// Role:      [Separable Pass 1/2] Performs a 3x1 horizontal erosion. Used for thinning edges or removing noise.
// Prerequisite: A grayscale or binary image.
// Input:     A single-channel image from 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate image with horizontal erosion applied.
//
float4 PSHorizontalErosion3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(texelWidth, 0.0f);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float min_val = min(val_prev, min(val_curr, val_next));

	return float4(min_val, min_val, min_val, 1.0f);
}

//
// Role:      [Separable Pass 2/2] Performs a 1x3 vertical erosion to complete the 3x3 erosion operation.
// Prerequisite: The intermediate image generated by PSHorizontalErosion3.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final grayscale image with erosion applied.
//
float4 PSVerticalErosion3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(0.0f, texelHeight);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float min_val = min(val_prev, min(val_curr, val_next));

	return float4(min_val, min_val, min_val, 1.0f);
}

//
// Role:      [Separable Pass 1/2] Performs a 3x1 horizontal dilation. Used for thickening edges or filling gaps.
// Prerequisite: A grayscale or binary image.
// Input:     A single-channel image from 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate image with horizontal dilation applied.
//
float4 PSHorizontalDilation3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(texelWidth, 0.0f);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float max_val = max(val_prev, max(val_curr, val_next));

	return float4(max_val, max_val, max_val, 1.0f);
}

//
// Role:      [Separable Pass 2/2] Performs a 1x3 vertical dilation to complete the 3x3 dilation operation.
// Prerequisite: The intermediate image generated by PSHorizontalDilation3.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final grayscale image with dilation applied.
//
float4 PSVerticalDilation3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(0.0f, texelHeight);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float max_val = max(val_prev, max(val_curr, val_next));

	return float4(max_val, max_val, max_val, 1.0f);
}

//
// Role:      Draws the input texture as is. Used for debugging or simple display.
// Prerequisite: The original video source from OBS.
// Input:     A color image from the 'image' texture.
// Uniforms:  None.
// Output:    The same color image as the input.
//
float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(def_sampler, vert_in.uv);
}

//
// Role:      Draws a single-channel input texture as a grayscale image. Used for viewing intermediate results.
// Prerequisite: A texture with luminance information in the red channel.
// Input:     A single-channel image from 'image.r'.
// Uniforms:  None.
// Output:    A grayscale image.
//
float4 PSDrawGrayscale(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	return float4(luma, luma, luma, 1.0f);
}
