#define SQRT_20 4.472136f

struct VertInOut {
	float4 pos : POSITION;
	float2 uv : TEXCOORD0;
};

//
// Role:      Converts a color image to a grayscale luminance map. This is the starting point for most subsequent operations.
// Prerequisite: Original Source (e.g., video input from OBS).
// Input:     The original color image from the 'image' texture.
// Uniforms:  None.
// Output:    A grayscale image with the luminance value stored in the .rgb channels (r=g=b).
//
float PSConvertGrayscale(VertInOut vert_in) : TARGET
{
	float4 color = image.Sample(def_sampler, vert_in.uv);
	float luma = saturate(dot(color.rgb, float3(0.2126, 0.7152, 0.0722)));
	return luma;
}

float median3(float v0, float v1, float v2)
{
	float a = min(v0, v1);
	float b = max(v0, v1);
	return max(a, min(b, v2));
}

//
// Role:      [Separable Pass 1/2] Applies a 1D horizontal median filter (3x1 kernel). This is the
//            first pass of a two-pass separable median filter used to reduce noise.
// Prerequisite: A grayscale image (e.g., a luminance map).
// Input:     A single-channel image from 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate image with horizontal medians applied, intended for the vertical pass.
//
float PSHorizontalMedian3(VertInOut vert_in) : TARGET
{
	float2 texelStep = float2(texelWidth, 0.0f);
	float s0 = image.Sample(def_sampler, vert_in.uv - texelStep).r;
	float s1 = image.Sample(def_sampler, vert_in.uv).r;
	float s2 = image.Sample(def_sampler, vert_in.uv + texelStep).r;
	return median3(s0, s1, s2);
}

//
// Role:      [Separable Pass 2/2] Applies a 1D vertical median filter (1x3 kernel) on the result
//            of the horizontal pass to complete the noise reduction.
// Prerequisite: The intermediate texture generated by the corresponding horizontal median pass.
// Input:     An intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final median-filtered grayscale image.
//
float PSVerticalMedian3(VertInOut vert_in) : TARGET
{
	float2 texelStep = float2(0.0f, texelHeight);
	float s0 = image.Sample(def_sampler, vert_in.uv - texelStep).r;
	float s1 = image.Sample(def_sampler, vert_in.uv).r;
	float s2 = image.Sample(def_sampler, vert_in.uv + texelStep).r;
	return median3(s0, s1, s2);
}

//
// Role:      [Separable Pass 1/2] Calculates the HORIZONTAL AVERAGE of absolute differences
//            for the motion map (3x1 kernel).
// Prerequisite: Two separate luminance maps (current and previous frames).
// Input:     'image.r' (current frame luminance), 'image1.r' (previous frame luminance).
// Uniforms:  texelWidth.
// Output:    The horizontal average of absolute differences, stored in .rgb.
//
float4 PSCalculateHorizontalMotionMap3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(texelWidth, 0.0f);
	float2 uv = vert_in.uv;

	float2 uv_prev = uv - texel_step;
	float2 uv_next = uv + texel_step;

	float sad = 0.0f;
	sad += abs(image.Sample(def_sampler, uv_prev).r - image1.Sample(def_sampler, uv_prev).r);
	sad += abs(image.Sample(def_sampler, uv).r - image1.Sample(def_sampler, uv).r);
	sad += abs(image.Sample(def_sampler, uv_next).r - image1.Sample(def_sampler, uv_next).r);

	float aad = saturate(sad / 3.0f);

	return float4(aad, aad, aad, 1.0);
}

//
// Role:      [Separable Pass 2/2] Calculates the VERTICAL AVERAGE of the horizontal
//            averages to finalize the motion map (1x3 kernel).
// Prerequisite: The intermediate texture generated by the horizontal pass.
// Input:     'image.r' (The result from the horizontal pass, i.e., horizontal averages).
// Uniforms:  texelHeight.
// Output:    The final, normalized motion map.
//
float4 PSCalculateVerticalMotionMap3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(0.0f, texelHeight);
	float2 uv = vert_in.uv;

	float aad_prev = image.Sample(def_sampler, uv - texel_step).r;
	float aad_curr = image.Sample(def_sampler, uv).r;
	float aad_next = image.Sample(def_sampler, uv + texel_step).r;

	float total_aad = aad_prev + aad_curr + aad_next;
	float final_aad = saturate(total_aad / 3.0f);

	return float4(final_aad, final_aad, final_aad, 1.0);
}

//
// Role:      Performs motion-adaptive temporal filtering by blending the current frame
//            with the previous frame, using a pre-calculated motion map to control
//            the blend strength.
// Prerequisite: Requires a motion map, the current frame, and the previous filtered frame.
// Input:     'image.r': The current (potentially noisy) grayscale frame.
//            'image1.r': The previously filtered grayscale frame (temporal accumulator).
//            'motionMap.r': A map where pixel intensity indicates the amount of motion.
// Uniforms:  strength, motionThreshold.
// Output:    A grayscale image with temporal noise reduction applied, stored in .rgb.
//
float4 PSMotionAdaptiveFiltering(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	float luma1 = image1.Sample(def_sampler, vert_in.uv).r;
	float motion = motionMap.Sample(def_sampler, vert_in.uv).r;
	float motionFactor = smoothstep(0.0, motionThreshold, motion);
	float blendFactor = strength * motionFactor;
	float finalLuma = lerp(luma1, luma, blendFactor);
	return float4(finalLuma, finalLuma, finalLuma, 1.0);
}

//
// Role:      [Canny Step 1] Applies the Sobel operator to calculate the gradient magnitude and direction.
// Prerequisite: A grayscale image (e.g., from PSConvertGrayscale or PSMedianFiltering).
// Input:     A grayscale image in 'image.r'.
// Uniforms:  texelWidth, texelHeight.
// Output:    .r = Gradient Magnitude (normalized), .g = Gx (encoded to [0,1]), .b = Gy (encoded to [0,1]).
//
float4 PSApplySobel(VertInOut vert_in) : TARGET
{
	float2 texel_size = float2(texelWidth, texelHeight);
	float2 uv = vert_in.uv;

	float luma[9];
	luma[0] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, -1.0f)).r;
	luma[1] = image.Sample(def_sampler, uv + texel_size * float2(0.0f, -1.0f)).r;
	luma[2] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, -1.0f)).r;
	luma[3] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, 0.0f)).r;
	luma[4] = image.Sample(def_sampler, uv).r;
	luma[5] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, 0.0f)).r;
	luma[6] = image.Sample(def_sampler, uv + texel_size * float2(-1.0f, 1.0f)).r;
	luma[7] = image.Sample(def_sampler, uv + texel_size * float2(0.0f, 1.0f)).r;
	luma[8] = image.Sample(def_sampler, uv + texel_size * float2(1.0f, 1.0f)).r;

	float gx = -luma[0] - 2.0f * luma[3] - luma[6] + luma[2] + 2.0f * luma[5] + luma[8];
	float gy = -luma[0] - 2.0f * luma[1] - luma[2] + luma[6] + 2.0f * luma[7] + luma[8];
	float magnitude = sqrt(gx * gx + gy * gy);

	// Normalize by a typical maximum gradient magnitude
	magnitude = saturate(magnitude / SQRT_20);
	gx = saturate(gx / 8.0f + 0.5f);
	gy = saturate(gy / 8.0f + 0.5f);

	return float4(magnitude, gx, gy, 1.0f);
}

//
// Role:      Adjusts the gradient magnitude with a scaling factor or logarithmic transformation.
// Prerequisite: A shader that outputs a grayscale gradient magnitude.
// Input:     A gradient magnitude in 'image.r'.
// Uniforms:  useLog, scalingFactor.
// Output:    A grayscale image with the adjusted magnitude in the .rgb channels.
//
float PSFinalizeSobelMagnitude3(VertInOut vert_in) : TARGET
{
	float magnitude = image.Sample(def_sampler, vert_in.uv).r;
	if (useLog) {
		magnitude = log(1.0f + magnitude) / log(2.0f);
	}
	magnitude = saturate(magnitude * scalingFactor);
	return magnitude;
}

//
// Role:      [Separable Pass 1/2] Performs HORIZONTAL morphological erosion (3x1 kernel).
// Prerequisite: A single-channel image (e.g., a binary edge map).
// Input:     A single-channel image in 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate texture with horizontal erosion applied.
//
float PSHorizontalErosion3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(texelWidth, 0.0f);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float min_val = min(val_prev, min(val_curr, val_next));

	return min_val;
}

//
// Role:      [Separable Pass 2/2] Performs VERTICAL morphological erosion on the
//            result of the horizontal pass (1x3 kernel).
// Prerequisite: The intermediate texture from the horizontal erosion pass.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final eroded grayscale image.
//
float PSVerticalErosion3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(0.0f, texelHeight);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float min_val = min(val_prev, min(val_curr, val_next));

	return min_val;
}

//
// Role:      [Separable Pass 1/2] Performs HORIZONTAL morphological dilation (3x1 kernel).
// Prerequisite: A single-channel image (e.g., a binary edge map).
// Input:     A single-channel image in 'image.r'.
// Uniforms:  texelWidth.
// Output:    An intermediate texture with horizontal dilation applied.
//
float PSHorizontalDilation3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(texelWidth, 0.0f);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float max_val = max(val_prev, max(val_curr, val_next));

	return max_val;
}

//
// Role:      [Separable Pass 2/2] Performs VERTICAL morphological dilation on the
//            result of the horizontal pass (1x3 kernel).
// Prerequisite: The intermediate texture from the horizontal dilation pass.
// Input:     The intermediate image from 'image.r'.
// Uniforms:  texelHeight.
// Output:    The final dilated grayscale image.
//
float PSVerticalDilation3(VertInOut vert_in) : TARGET
{
	float2 texel_step = float2(0.0f, texelHeight);

	float val_prev = image.Sample(def_sampler, vert_in.uv - texel_step).r;
	float val_curr = image.Sample(def_sampler, vert_in.uv).r;
	float val_next = image.Sample(def_sampler, vert_in.uv + texel_step).r;

	float max_val = max(val_prev, max(val_curr, val_next));

	return max_val;
}

//
// Role:      Simply draws the source texture.
// Prerequisite: Original Source (e.g., video input from OBS).
// Input:     The original color image from the 'image' texture.
// Uniforms:  None.
// Output:    The same color image as the input.
//
float4 PSDraw(VertInOut vert_in) : TARGET
{
	return image.Sample(def_sampler, vert_in.uv);
}

//
// Role:      Draws a single-channel source as a grayscale image.
// Prerequisite: A texture where the desired value is in the red channel.
// Input:     A texture from 'image.r'.
// Uniforms:  None.
// Output:    A grayscale image.
//
float4 PSDrawGrayscale(VertInOut vert_in) : TARGET
{
	float luma = image.Sample(def_sampler, vert_in.uv).r;
	return float4(luma, luma, luma, 1.0f);
}